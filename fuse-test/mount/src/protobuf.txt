// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Function {
    #[prost(uint64, tag = "1")]
    pub memory: u64,
    /// Blob fd
    #[prost(uint64, tag = "2")]
    pub app_image: u64,
    /// Blob fd
    #[prost(uint64, tag = "3")]
    pub runtime: u64,
    /// Blob fd
    #[prost(uint64, tag = "4")]
    pub kernel: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TokenList {
    #[prost(string, repeated, tag = "1")]
    pub tokens: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Clause {
    /// A disjuction of principals
    #[prost(message, repeated, tag = "1")]
    pub principals: ::prost::alloc::vec::Vec<TokenList>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClauseList {
    #[prost(message, repeated, tag = "1")]
    pub clauses: ::prost::alloc::vec::Vec<Clause>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Component {
    #[prost(oneof = "component::Component", tags = "1, 2")]
    pub component: ::core::option::Option<component::Component>,
}
/// Nested message and enum types in `Component`.
pub mod component {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Component {
        #[prost(message, tag = "1")]
        DcFalse(super::Void),
        /// A conjunction of clauses
        #[prost(message, tag = "2")]
        Clauses(super::ClauseList),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Buckle {
    /// None means DcFalse, empty clauses means DcTrue, otherwise DcFormula
    #[prost(message, optional, tag = "1")]
    pub secrecy: ::core::option::Option<Component>,
    /// None means DcFalse, empty clauses means DcTrue, otherwise DcFormula
    #[prost(message, optional, tag = "2")]
    pub integrity: ::core::option::Option<Component>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Void {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Request {
    #[prost(bytes = "vec", tag = "1")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
    #[prost(map = "string, uint64", tag = "2")]
    pub blobs: ::std::collections::HashMap<::prost::alloc::string::String, u64>,
    #[prost(map = "string, string", tag = "3")]
    pub headers: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// list of principals in the invoker's privilege
    #[prost(message, repeated, tag = "4")]
    pub invoker: ::prost::alloc::vec::Vec<TokenList>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Response {
    #[prost(bytes = "vec", optional, tag = "1")]
    pub body: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(uint32, tag = "2")]
    pub status_code: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DentResult {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(uint64, optional, tag = "2")]
    pub fd: ::core::option::Option<u64>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DentInvokeResult {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(uint64, optional, tag = "2")]
    pub fd: ::core::option::Option<u64>,
    #[prost(bytes = "vec", optional, tag = "3")]
    pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(map = "string, bytes", tag = "4")]
    pub headers: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::vec::Vec<u8>,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DentOpenResult {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(uint64, tag = "2")]
    pub fd: u64,
    #[prost(enumeration = "DentKind", tag = "3")]
    pub kind: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BlobCreate {
    #[prost(uint64, optional, tag = "1")]
    pub size: ::core::option::Option<u64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlobWrite {
    #[prost(uint64, tag = "1")]
    pub fd: u64,
    #[prost(bytes = "vec", tag = "2")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BlobFinalize {
    #[prost(uint64, tag = "1")]
    pub fd: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BlobRead {
    #[prost(uint64, tag = "1")]
    pub fd: u64,
    #[prost(uint64, optional, tag = "2")]
    pub offset: ::core::option::Option<u64>,
    #[prost(uint64, optional, tag = "3")]
    pub length: ::core::option::Option<u64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct BlobClose {
    #[prost(uint64, tag = "1")]
    pub fd: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DentOpen {
    #[prost(uint64, tag = "1")]
    pub fd: u64,
    #[prost(oneof = "dent_open::Entry", tags = "2, 3")]
    pub entry: ::core::option::Option<dent_open::Entry>,
}
/// Nested message and enum types in `DentOpen`.
pub mod dent_open {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Entry {
        #[prost(string, tag = "2")]
        Name(::prost::alloc::string::String),
        #[prost(message, tag = "3")]
        Facet(super::Buckle),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DentLink {
    #[prost(uint64, tag = "1")]
    pub dir_fd: u64,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub target_fd: u64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DentCreate {
    #[prost(message, optional, tag = "1")]
    pub label: ::core::option::Option<Buckle>,
    #[prost(oneof = "dent_create::Kind", tags = "2, 3, 4, 5, 6, 7")]
    pub kind: ::core::option::Option<dent_create::Kind>,
}
/// Nested message and enum types in `DentCreate`.
pub mod dent_create {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(message, tag = "2")]
        Directory(super::Void),
        #[prost(message, tag = "3")]
        File(super::Void),
        #[prost(message, tag = "4")]
        FacetedDirectory(super::Void),
        #[prost(message, tag = "5")]
        Gate(super::Gate),
        #[prost(message, tag = "6")]
        Service(super::Service),
        #[prost(uint64, tag = "7")]
        Blob(u64),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DentUpdate {
    #[prost(uint64, tag = "1")]
    pub fd: u64,
    #[prost(oneof = "dent_update::Kind", tags = "3, 5, 6, 7")]
    pub kind: ::core::option::Option<dent_update::Kind>,
}
/// Nested message and enum types in `DentUpdate`.
pub mod dent_update {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        /// Void    directory        = 2;
        #[prost(bytes, tag = "3")]
        File(::prost::alloc::vec::Vec<u8>),
        /// Void    facetedDirectory = 4;
        #[prost(message, tag = "5")]
        Gate(super::Gate),
        #[prost(message, tag = "6")]
        Service(super::Service),
        #[prost(uint64, tag = "7")]
        Blob(u64),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Gate {
    #[prost(oneof = "gate::Kind", tags = "1, 2")]
    pub kind: ::core::option::Option<gate::Kind>,
}
/// Nested message and enum types in `Gate`.
pub mod gate {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Kind {
        #[prost(message, tag = "1")]
        Direct(super::DirectGate),
        #[prost(message, tag = "2")]
        Redirect(super::RedirectGate),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DirectGate {
    #[prost(message, optional, tag = "1")]
    pub privilege: ::core::option::Option<Component>,
    #[prost(message, optional, tag = "2")]
    pub invoker_integrity_clearance: ::core::option::Option<Component>,
    #[prost(message, optional, tag = "3")]
    pub function: ::core::option::Option<Function>,
    #[prost(message, optional, tag = "4")]
    pub declassify: ::core::option::Option<Component>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RedirectGate {
    #[prost(message, optional, tag = "1")]
    pub privilege: ::core::option::Option<Component>,
    #[prost(message, optional, tag = "2")]
    pub invoker_integrity_clearance: ::core::option::Option<Component>,
    #[prost(uint64, tag = "3")]
    pub gate: u64,
    #[prost(message, optional, tag = "4")]
    pub declassify: ::core::option::Option<Component>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Service {
    #[prost(message, optional, tag = "1")]
    pub privilege: ::core::option::Option<Component>,
    #[prost(message, optional, tag = "2")]
    pub invoker_integrity_clearance: ::core::option::Option<Component>,
    #[prost(message, optional, tag = "3")]
    pub taint: ::core::option::Option<Buckle>,
    #[prost(string, tag = "4")]
    pub url: ::prost::alloc::string::String,
    #[prost(enumeration = "HttpVerb", tag = "5")]
    pub verb: i32,
    #[prost(map = "string, string", tag = "6")]
    pub headers: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DentListResult {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(map = "string, enumeration(DentKind)", tag = "2")]
    pub entries: ::std::collections::HashMap<::prost::alloc::string::String, i32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DentLsFacetedResult {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(message, repeated, tag = "2")]
    pub facets: ::prost::alloc::vec::Vec<Buckle>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DentLsGateResult {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(message, optional, tag = "2")]
    pub gate: ::core::option::Option<Gate>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DentLsFaceted {
    #[prost(uint64, tag = "1")]
    pub fd: u64,
    #[prost(message, optional, tag = "2")]
    pub clearance: ::core::option::Option<Buckle>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DentUnlink {
    #[prost(uint64, tag = "1")]
    pub fd: u64,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DentInvoke {
    #[prost(uint64, tag = "1")]
    pub fd: u64,
    #[prost(bool, tag = "2")]
    pub sync: bool,
    #[prost(bytes = "vec", tag = "3")]
    pub payload: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag = "4")]
    pub toblob: bool,
    #[prost(map = "string, string", tag = "5")]
    pub parameters: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BlobResult {
    #[prost(bool, tag = "1")]
    pub success: bool,
    #[prost(uint64, tag = "2")]
    pub fd: u64,
    #[prost(uint64, tag = "3")]
    pub len: u64,
    #[prost(bytes = "vec", optional, tag = "4")]
    pub data: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MaybeBuckle {
    #[prost(message, optional, tag = "1")]
    pub label: ::core::option::Option<Buckle>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Syscall {
    #[prost(
        oneof = "syscall::Syscall",
        tags = "1, 2, 3, 4, 5, 6, 99, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 100, 101, 102, 103, 104"
    )]
    pub syscall: ::core::option::Option<syscall::Syscall>,
}
/// Nested message and enum types in `Syscall`.
pub mod syscall { // subnamespace - namespace inside the current scope
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Syscall {
        /// Send function response. Marks completion of the function, doesn't return a value
        #[prost(message, tag = "1")]
        Response(super::Response),
        /// returns MaybeBuckle
        #[prost(string, tag = "2")]
        BuckleParse(::prost::alloc::string::String),
        /// returns Buckle
        #[prost(message, tag = "3")]
        GetCurrentLabel(super::Void),
        /// rerturns Buckle (new current label)
        #[prost(message, tag = "4")]
        TaintWithLabel(super::Buckle),
        /// returns Buckle (new current label)
        #[prost(message, tag = "5")]
        Declassify(super::Component),
        #[prost(message, tag = "6")]
        SubPrivilege(super::TokenList),
        /// returns DentResult
        #[prost(message, tag = "99")]
        Root(super::Void),
        /// returns DentOpenResult
        #[prost(message, tag = "7")]
        DentOpen(super::DentOpen),
        /// returns DentResult
        #[prost(uint64, tag = "8")]
        DentClose(u64),
        /// returns DentResult
        #[prost(message, tag = "9")]
        DentCreate(super::DentCreate),
        /// returns DentResult
        #[prost(message, tag = "10")]
        DentUpdate(super::DentUpdate),
        /// returns DentResult
        #[prost(uint64, tag = "11")]
        DentRead(u64),
        /// returns DentListResult
        #[prost(uint64, tag = "12")]
        DentList(u64),
        /// returns DentLsFacetedResult
        #[prost(message, tag = "13")]
        DentLsFaceted(super::DentLsFaceted),
        /// returns DentResult
        #[prost(message, tag = "14")]
        DentLink(super::DentLink),
        /// returns DentResult
        #[prost(message, tag = "15")]
        DentUnlink(super::DentUnlink),
        /// returns DentInvokeResult
        #[prost(message, tag = "16")]
        DentInvoke(super::DentInvoke),
        /// returns DentLsGateResult
        #[prost(uint64, tag = "17")]
        DentLsGate(u64),
        /// returns BlobResult
        #[prost(uint64, tag = "18")]
        DentGetBlob(u64),
        /// returns BlobResult
        #[prost(message, tag = "100")]
        BlobCreate(super::BlobCreate),
        /// returns BlobResult
        #[prost(message, tag = "101")]
        BlobWrite(super::BlobWrite),
        /// returns BlobResult
        #[prost(message, tag = "102")]
        BlobFinalize(super::BlobFinalize),
        /// returns BlobResult
        #[prost(message, tag = "103")]
        BlobRead(super::BlobRead),
        /// returns BlobResult
        #[prost(message, tag = "104")]
        BlobClose(super::BlobClose),
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DentKind {
    DentDirectory = 0,
    DentFile = 1,
    DentFacetedDirectory = 2,
    DentGate = 3,
    DentService = 4,
    DentBlob = 5,
}
impl DentKind {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            DentKind::DentDirectory => "DentDirectory",
            DentKind::DentFile => "DentFile",
            DentKind::DentFacetedDirectory => "DentFacetedDirectory",
            DentKind::DentGate => "DentGate",
            DentKind::DentService => "DentService",
            DentKind::DentBlob => "DentBlob",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DentDirectory" => Some(Self::DentDirectory),
            "DentFile" => Some(Self::DentFile),
            "DentFacetedDirectory" => Some(Self::DentFacetedDirectory),
            "DentGate" => Some(Self::DentGate),
            "DentService" => Some(Self::DentService),
            "DentBlob" => Some(Self::DentBlob),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum HttpVerb {
    HttpHead = 0,
    HttpGet = 1,
    HttpPost = 2,
    HttpPut = 3,
    HttpDelete = 4,
}
impl HttpVerb {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            HttpVerb::HttpHead => "HttpHead",
            HttpVerb::HttpGet => "HttpGet",
            HttpVerb::HttpPost => "HttpPost",
            HttpVerb::HttpPut => "HttpPut",
            HttpVerb::HttpDelete => "HttpDelete",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "HttpHead" => Some(Self::HttpHead),
            "HttpGet" => Some(Self::HttpGet),
            "HttpPost" => Some(Self::HttpPost),
            "HttpPut" => Some(Self::HttpPut),
            "HttpDelete" => Some(Self::HttpDelete),
            _ => None,
        }
    }
}